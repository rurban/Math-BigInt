See also various .pm files.

General:
 * Copy on write (helps for $x = -$x; cases etc) (seems to make it slower :/
 * try to cash UNIVERSAL::can results, since $CALC shouldn't change (or even
   unset them when $CALC changes)

Math::BigFloat:
 * finish upgrading and downgrading
 * ! bround()/bfround(): some bugs may lurk in there
 * accuracy() & precision() maybe not finished (bnorm() in every op, testcases)
 * do not reduce numbers in new(), rather do it in anything that outputs it
   like bsstr(), bstr(), mantissa(), exponent() and parts(). Reducing the
   number after each op is slow with a binary core math lib like BitVect.
 * ?? add $x->bint(), that rounds with 'trunc' to an integer ??
 * tests for frsft() and flsft() with $n != 2
 * blog() is dead slow, and doesn't work for bases != e (aka only ln() works)
 * bsqrt(): maybe optimize the diff-compare away?

Math::BigFloat::Constant:
 * really needed by someone out there?

Math::BigInt:
 * finish 'upgrade'
 * remove rounding overhead when no rounding is done, e.g. no $object has A nor
   P and neither of bround(), bround(), accuracy() or precision() was called
 * bround() is only used by MBF for -$scale = -$len, anyway. POD is wrong for
   this, too.
 * +5 % 0 or -5 % 0 == NaN (should it be something else?)
 * certain shortcuts returning bzero(), bone() etc may not set the requested
   rounding parameters, so that $x->foo($y,$a,$p,$r) may return $x without a
   set $a or $p, thus failing later on:

	use Test;
	BEGIN { plan tests => 1; }
	use Math::BigInt;
	$x = Math::BigInt->bone();
	$x->bsqrt(3,0,'odd');		# $x = 0, but _a is not 3!
	ok ($x + '12345','12300');	# fails (12346 instead of 12300)

   The shortcuts in code that return $x->bzero() or similiar things need to
   do $x->bzero($a,$p); and this needs tests.
   Update: Should now work for most things. Check for completeness.

Given the fact that we are be able to plug-in a much faster core-lib, the
following are pretty much ultra-low-priority:

Math::BigInt::Calc:
 * bpow() could be faster by not using div() (pre-shift only last array elem?)
 * look at div() for more speed
 * code a div() algorithmn for $y < $BASE (e.g. should be something linear)
 * alternative mul() method using shifts
 * find a way to let underlying lib calculate band(), bior(), bxor() for
   negative inputs
 * make converting between bases faster
 * add _modinv() for more speed

Please send me test-reports, your experiences with this and your ideas - I love
to hear about my work!

Tels <http://bloodgate.com/>
